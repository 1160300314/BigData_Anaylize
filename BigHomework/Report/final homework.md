# 大数据分析大作业

## BackGround

### Content Addressable Network(CAN)

CAN是一种自组织性很强的P2P覆盖网络，一个$d$维的CAN的划分是将一个$d$维的坐标系划分到不同的节点上去。数据是通过一个$hash$函数来将数据的主键划分为$d$维的坐标，从而划分数据到不同的CAN节点上的。对于一个CAN节点$N_i$来说，它会保存所有和$N_i$对应的空间的邻接空间的ip地址，从而形成一个P2P网络。因为CAN网络的自组织性很强，所以一个节点可以很自由地加入或者离开一个CAN，就像P2P网络一样，只需要发送信息更改网络拓扑即可。

我们使用的RT-CAN索引的构建是基于一种CAN的变种，$C^2$来实现的。$C^2$除了有CAN的特征外，它还在划分坐标系的每个维度上添加了和弦邻居链接(Chord-like neighbor link)。具体而言，在每个维度上距离为$2^0,2^1,\cdots$的节点上添加链接。因为我们要实现的是分布式空间近似关键字查询，所以我们选择中2维的$C^2$来实现的RT-CAN索引。

我们要处理的是空间近似关键字查询以及$KNN$，$RkNN$近似关键字查询，所以我们的数据的key值就可以看作是2维的位置坐标，这样很自然的就可以想到对CAN的划分也是在2维坐标中而且可以和位置信息对应起来，即$hash$函数不对输入进行转换。

## 数据划分

数据的划分我们使用的是一种类似于KD树划分的方法。我们知道，KD树有一种划分的算法按照如下的方法进行：

1. 从方差最高的维度开始，并按照这个维度的数据值对空间进行划分，一般取方差最高的那个维度的值的中值作为划分值；

2. 重复在下一个方差最高的维度继续进行划分，直到空间被划分成想要的份数。

我们的划分和这种对KD树的划分有所不同。对于分布式系统，我们更关心的是每个计算节点的数据分配和负载平衡，所以我们对其作一定的修改。首先，设置一个阈值参数$P_{max}$，然后按照如下的方法进行划分：

1. 判断数据点的数量是否小于$P_{max}$，如果小于则无需划分。否则找到数据中方差最高的维度，按照这个维度的中值作为划分值划分数据；

2. 重复对每一个数据点个数大于$P_{max}$的块进行划分：找到块中方差最高的维度，按照这个维度的中值作为划分值划分这个块。

这样，我们就能保证每个块中的数据点数量不少于$P_{max}/2$而且不多于$P_{max}$，保证了一定的负载均衡而且保证数据量不超过阈值$P_{max}$，防止节点负载过大。当数据量大的时候可以选择尽可能较大的$P_{max}$充分利用每个节点的存储计算性能；当数据量小的时候可以适量调小$P_{max}$以便数据更分散地分配到各个节点中提高并行性。

## 第一层索引

我们使用RT-CAN索引作为我们的第一层索引，即寻找存储节点的索引。RT-CAN索引是一种建立在本地索引之上的索引[1]。它使用$C^2$网络作为底层存储节点分布，通过定义R树数据节点如何划分到各个存储节点来得到数据的组织方式，并且定义相关算法能对其中的数据进行查询。下面首先介绍RT-CAN节点的结构，然后介绍如何构造RT-CAN索引。

### 节点结构

RT-CAN索引是建立在一个shared-nothing的集群上的。如图1所示，集群中的每一个节点$N_i$都包含了两个部分：一个是存储节点$N_{si}$，另一个是覆盖节点$N_{oi}$。$N_{si}$表示的是分布式存储的特征，它存储着所有数据划分的一部分。为了满足空间近似查询，以及空间近似的$kNN$和$RkNN$查询，$N_{si}$使用了一种R树的变种来存储局部数据，从而满足我们的查询需求。$N_{oi}$是用来表示CAN结构化覆盖的部分，它负责的是CAN划分的一部分。对于CAN的网络通信来说，$N_{si}$会适应性的选择一部分局部R树的结点，然后通过$N_{oi}$来将这些节点信息发送到CAN网络中。发送的信息结果为一个二元组$(ip,mbr)$，其中ip是$N_i$节点的IP地址，$mbr$是这个R树结点的范围。当$N{si}$收到$N_{oi}$的发送请求时，$N{si}$就会选择相应的R树结点并将其map成为一个CAN节点，并通过CAN的路由协议将请求发出。$N_{oi}$维护着全局索引，当它收到一个广播请求，它就通过map方法判断这是否是它要接受的请求。如果时，它就保留一份广播的R树的结点当作索引并保存。这样就能做到用一些R树的结点来当作索引并将其分布在集群中。

![图1](figure1.png)

### 索引构造

基于我们的需求，我们使用的是二维的$C^2$来构建我们的RT-CAN索引。前面提到我们需要一个map方法将一个R树结点map为一个CAN节点，这样的map方法一般要以这个R树节点的中心和半径来确定。对一个二维的R树节点$n$，范围为$[l_1,u_1],[l_2,u_2]$，中心和半径分别表示为$c_n=(\frac{l_1+u_1}{2}),r_n=\frac{1}{2}\sqrt{(u_1-l_1)^2+(u_2-l_2)^2}$。首先，对于R树节点$n$，我们首先把它map到包含$n$的中心$c_n$的CAN节点$N_c$上，然后$N_c$会比较$n$半径和定义的一阈值参数$R_{max}$，如果$n$的半径小于$R_{max}$，就只需要map给这一个CAN节点，否则就需要将$n$发送给所有和$n$范围覆盖的所有CAN节点。这样可能会导致一些副本的出现，但同时也会提升查询的效率，因为只保存一个索引会导致所有相关的搜索都要在网络中查询这个索引，会降低查询效率。

然后，对于索引的构造，对于每个CAN节点，若假设其存储的R树是$L$层的，我们就选择将R树的$L-1$层的所有R树节点发送，因为它们不是经常被更新的，这样就减少了更新索引的次数。然后对每个CAN节点都执行发送的操作，然后就可以按照我们前面提到的map算法来判断如何构造我们的全局索引。

## 查询

对于RT-CAN索引来说，我们能得到下面两个定理。

**定理1**：对一个点查询$Q(key)$，如果我们查询了所有以$key$为圆心，$R_{max}$为半径的的圆覆盖的所有的CAN，那么我们就一能得到完整的结果。

**定理2**：对于一个范围查询$Q(range)$，如果我们查询了所有以$range$的中心为圆心，$R_{max}+range.radius$为半径的源覆盖的所有的CAN，那么我们就一定能得到完整的结果。

所以点查询和范围查询的区别就在查询的半径不同。以点查询为例，首先，我们需要将查询发给一个$N_{init}$，它的范围必须包含我们要查询的点$key$，然后查询$N_{init}$的全局索引，返回一个结果集合；然后对于搜索圆覆盖的所有的CAN，我们通过一个递归的方法来进行查询。对于$d$维的搜索空间，根据$N_{init}$在每一维的范围$l_i$和$u_i$，将搜索圆$C$划分为三个部分：在这一维小于$l_i$的部分$R_1$、这一维的数在$l_i$和$u_i$之间的部分$R_0$、在这一维大于$u_i$的部分$R_2$。然后通过$R_1$和$R_2$的范围找到$N_{init}$在这个范围内的邻居，并对其发送查询请求，邻居通过递归调用这个算法来继续执行查询。对于$R_0$而言，每次在一个维度划分结束后得到的$R_0$将继续作为输入在下一个维度进行划分。这样我们就能得到一个R树结点索引的集合，通过这些索引我们能找到我们要查询的所有点。

范围查询和点查询类似，不同的地方就是查询圆的半径不同，我们可以通过相同的查询、分割方法得到范围查询的结果。

## 数据备份

为了使系统有一定的对抗异常状态的容错能力，数据备份是必不可少的，这里我们选择使用primary-secondary的中心副本控制协议来实现数据的备份并维护副本之间的一致性。在primary-secondary协议中，副本被分为两类，其中有一个副本被当作primary副本，它是中心节点，负责维护数据的更新，并发控制以及维护副本之间的一致性等。其他的副本都是secondary副本。

如图2所示，数据更新的过程中，外部的节点发送请求给primary节点，然后primary节点再将更新操作分发给所属它的secondary节点。这个过程我们选择提供最终一致性，即secondary节点和primary节点不一致，需要的只是后续过程中secondary节点能够可以同步到primary一致的状态即可。但是可能发生的问题就是secondary未与primary更新一致的情况下primary节点又收到了一个更新请求，会产生不一致的情况。对于这种情况，我们选择在secondary节点同步到和primary节点过程中，secondary节点同步到primary某个时刻的快照（snapshot）的状态，更新完如果仍不一致则继续更新。

数据更新过程中由于secondary节点的数据可能会落后于primary节点，所以一些存储“旧”数据的secondary节点的部分数据其实是不可用的。为了解决这个问题，我们将secondary节点的状态分为两种：一种是与primary一致的状态，这时可以读取其中的数据；另一种是被标记为不可用的状态，表明secondary节点的数据仍处于被更新的状态从而无法读取其中的数据。从某种意义上来讲，这种方法通过降低了一定的可用性来提高系统的一致性。

primary节点宕机后，选择合适的primary副本进行替换也是很重要的一个问题。和更新类似，选择一个状态为和primary节点一致的secondary节点替换primary节点即可。但是可能存在的状态是所有的secondary节点都恰好是不可用的状态，对于这种情况，我们选择通过日志来对secondary的记录进行恢复。设置检查点（checkpoint），在检查点之后将secondary节点的数据利用日志记录进行更新，使其成为primary节点宕机前的状态即可。

## 数据增删和索引维护

数据的插入和删除最终都可以定位到局部R树的插入和删除，从而可能会引起一些R树节点发生变化。如果引起变化的结点是已经发送到全局索引的节点的话，这时候就会产生一部分的“脏”索引，通过这些索引查找结果很可能会将查找引导到不正确的存储节点上。

为了解决这个问题，对于已经发送到全局作为索引的R树结点$n_{old}$，会给其一个标记表示这个节点已被发送到全局索引。如果插入和删除动作导致$n_{old}$分割或者合并的话，我们需要重新将这个新的R树节点集合$S_{new}$发送，从而替代之前发送的已经
过时的索引。替代过程分删除源索引和添加新索引两部分。因为$n_{old}$和$S_{new}$中各结点的中心和半径不同，所以要按$n_{old}$的中心和半径发布删除信息将旧的索引结点全都删除；然后对于$S_{new}$中的各个节点，按照它们的中心和半径发送索引消息作为新的全局索引存储即可。

数据的插入和删除首先会按照R树的维护方法来对树进行更新，然后对本地MVR树来说，其结构的维护还需要需要考虑两个方面：一方面要考虑更新叶子节点上保存的Voronoi图的信息，另一方面还需要维护叶子节点上保存的min-hash信息以及非叶节点保存的min-hash签名。接下来分别考虑这两方面的信息如何来维护。

首先考虑Voronoi图信息的维护，这个过程其实就是动态维护Voronoi图关系的过程[2]。插入一个点$p$，我们首先能定位它的位置并且找到离它最近的点$x$，很明显我们可以得到点$p$在以点$x$为中心的cell内。然后我们主要的任务就是找到插入点$p$而受影响的那些点，由于Voronoi图的结构，我们容易得到，和点$p$有公共边的点一定在原Voronoi图中和点$x$有公共边，所以我们只需判断这些点中那些受影响即可。然后对于这些点，重新求他们的公共边并更新他们存储的Voronoi图信息即可。

删除一个点$q$，我们首先要通过其R树的结构来定位这个点，然后通过点记录的信息得到它的邻居，得到需要修改的所有顶点的集合。然后访问每一个邻居，在他们记录的邻居信息中删除点$q$。所有需要修改的顶点都做完删除操作后，再重构这些点中保存的边获得删除点$q$后的Voronoi图的结构。

然后考虑维护叶节点上保存的min-hash信息以及非叶节点保存的min-hash签名。插入一个节点$p$，首先需要计算它的min-hash信息，然后，比较它的值和包含它的叶节点保存的min-hash值，并取最小的作为新的值。如果对叶节点上保存的min-hash信息进行了更新的话，需要把这个变化传递给它的父节点，然后父节点执行相似的动作：如果更新的值小于原来存储的min-hash值就对其进行替换。这样的操作会一直执行到不再更新父节点的min-hash签名，一次插入结束。

删除一个点$q$，如果点$q$的签名和这个位置的签名相同的话，我们就需要重新计算出去这个点的这个位置的min-hash值。如果叶节点更新的话，就执行和插入类似的操作来迭代地更新父节点的值直到停止即可。。

## 参考文献

[1] Wang J, Wu S, Gao H, et al. Indexing multi-dimensional data in a cloud system[C]// Acm Sigmod International Conference on Management of Data. 2010.

[2]Okabe A, Boots B, Sugihara K. Spatial tessellations. Concepts and Applications of Voronoi diagrams[J]. College Mathematics Journal, 2001, 43(1).
